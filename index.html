<html>
<head>
<title>BioParticles</title>
<script src="pixi.js"></script>
</head>
<body>
	
<script type="text/javascript">

	function getRandSymbol(){
		var res = Math.random();
		if(res > 0.5) return 1;
		if(res <= 0.5) return -1;
	}

	var canvas_size_x = 1200;
	var canvas_size_y = 600;
	var n_particles = 3;

	var app = new PIXI.Application(canvas_size_x, canvas_size_y, { antialias: true, backgroundColor : 0x1099bb});
	document.body.appendChild(app.view);

	var graphics = new PIXI.Graphics();
	app.stage.addChild(graphics);

	var Particle = function () {
		this.name = "Particle";
		this.x = 100;
		this.y = 100;
		this.size = 10;
		this.mass = 10;
		this.vel = [1,1];
		this.color = 0xFFFFFF;
		//percentage of speed lost in each frame:
		this.friction = 0.0005;
		this.interactions = [{name:"repel", interacts_with: "Particle", direction: -1, range: 10*this.size, force:10}];
	};

	Particle.prototype.draw = function(graphics){
		// draw a circle, set the lineStyle to zero so the circle doesn't have an outline
		graphics.lineStyle(0);
		graphics.beginFill(this.color, 0.5);
		graphics.drawCircle(this.x, this.y, this.mass);
		graphics.endFill();

	};

	Particle.prototype.move = function(canvas_size_x, canvas_size_y){

		//apply velocity:
		this.x += this.vel[0];
		this.y += this.vel[1];
		//apply friction:
		if (this.vel[0] != 0) this.vel[0] -= this.vel[0]*this.friction;
		if (this.vel[1] != 0) this.vel[1] -= this.vel[1]*this.friction;

		//borders
		if(this.x + this.size > canvas_size_x || this.x - this.size < 0) this.vel[0] =  -this.vel[0];
		if(this.y + this.size > canvas_size_y || this.y - this.size < 0) this.vel[1] =  -this.vel[1];
	};

	Particle.prototype.getDistanceBounderies = function(p){
		var distance = Math.sqrt(Math.pow(p.x -this.x,2)+Math.pow(p.y - this.y,2));
		//remove the particle size from the distance
		distance -= (this.size + p.size);
		if(distance < 0) distance = 0;
		//console.log(distance);
		return distance;
	};

	Particle.prototype.getDistanceCenter = function(p){
		var distance = Math.sqrt(Math.pow(p.x -this.x,2)+Math.pow(p.y - this.y,2));
		//console.log(distance);
		return distance;
	};


	function elastic_bounce(p1, p2) {
		//ellastic newtonian collision

		var velocity_conservation = 0.0001; 
	    var dx = p2.x-p1.x;
	    var dy = p2.y-p1.y;
	    var collisionision_angle = Math.atan2(dy, dx);
	    var magnitude_1 = Math.sqrt(p1.vel[0]*p1.vel[0]+p1.vel[1]*p1.vel[1]);
	    var magnitude_2 = Math.sqrt(p2.vel[0]*p2.vel[0]+p2.vel[1]*p2.vel[1]);
	    var direction_1 = Math.atan2(p1.vel[1], p1.vel[0]);
	    var direction_2 = Math.atan2(p2.vel[1], p2.vel[0]);
	    var new_xspeed_1 = magnitude_1*Math.cos(direction_1-collisionision_angle);
	    var new_yspeed_1 = magnitude_1*Math.sin(direction_1-collisionision_angle);
	    var new_xspeed_2 = magnitude_2*Math.cos(direction_2-collisionision_angle);
	    var new_yspeed_2 = magnitude_2*Math.sin(direction_2-collisionision_angle);
	    var final_xspeed_1 = ((p1.mass-p2.mass)*new_xspeed_1+(p2.mass+p2.mass)*new_xspeed_2)/(p1.mass+p2.mass);
	    var final_xspeed_2 = ((p1.mass+p1.mass)*new_xspeed_1+(p2.mass-p1.mass)*new_xspeed_2)/(p1.mass+p2.mass);
	    var final_yspeed_1 = new_yspeed_1;
	    var final_yspeed_2 = new_yspeed_2;
	    //p1.vel[0] = velocity_conservation*(Math.cos(collisionision_angle)*final_xspeed_1+Math.cos(collisionision_angle+Math.PI/2)*final_yspeed_1);
	    //p1.vel[1] = velocity_conservation*(Math.sin(collisionision_angle)*final_xspeed_1+Math.sin(collisionision_angle+Math.PI/2)*final_yspeed_1);
	    p2.vel[0] = velocity_conservation*(Math.cos(collisionision_angle)*final_xspeed_2+Math.cos(collisionision_angle+Math.PI/2)*final_yspeed_2);
	    p2.vel[1] = velocity_conservation*(Math.sin(collisionision_angle)*final_xspeed_2+Math.sin(collisionision_angle+Math.PI/2)*final_yspeed_2);
	}

	//initialize particles
	var particles = [];

	//electrons
	for (var i = 0; i <30; i++)
	{
		var p = new Particle();
		p.size = Math.floor((Math.random() * 10) + 7);
		p.mass = p.size;
		p.color = 0xffffff;
		p.x = Math.floor((Math.random() * canvas_size_x - p.size) + p.size);
		p.y = Math.floor((Math.random() * canvas_size_y - p.size) + p.size);
		p.vel = [Math.floor((Math.random() * 8) + 1)*getRandSymbol(), Math.floor((Math.random() * 8) + 1)*getRandSymbol()];
		p.name = "Electron";
		p.interactions = [{name:"repel", interacts_with: "Electron", direction: 1, range: 10*p.size, force:10},
						  {name:"attract", interacts_with: "Proton", direction: -1, range: 10* p.size, force:10}];
		particles.push(p);
	}

	//protons
	for (var i = 0; i < 30; i++)
	{
		var p = new Particle();
		p.size = Math.floor((Math.random() * 7) + 4);
		p.mass = p.size;
		p.color = 0xff0000;
		p.x = Math.floor((Math.random() * canvas_size_x - p.size) + p.size);
		p.y = Math.floor((Math.random() * canvas_size_y - p.size) + p.size);
		p.vel = [Math.floor((Math.random() * 8) + 1)*getRandSymbol(), Math.floor((Math.random() * 8) + 1)*getRandSymbol()];
		p.name = "Proton";
		p.interactions = [{name:"repel", interacts_with: "Proton", direction: 1, range: 10* p.size, force:10},
						  {name:"attract", interacts_with: "Electron", direction: -1, range: 10*p.size, force:10}];
		particles.push(p);
	}

	// Listen for animate update
	app.ticker.add(function(delta) {
		graphics.clear();
		for (var i = 0; i < particles.length; i++)
		{
			particles[i].move(canvas_size_x, canvas_size_y);
			particles[i].draw(graphics);

			//process collisions:
			for (var j = 0; j < particles.length; j++)
			{
				if(i != j){
					//check all interactions
					for (var l = 0; l < particles[i].interactions.length; l++)
					{
						//compare particle names to see if there's an interaction
						if(particles[i].interactions[l].interacts_with == particles[j].name){
							
							var distance_bounderies = particles[i].getDistanceBounderies(particles[j]);
							var distance_center = particles[i].getDistanceCenter(particles[j]);
							if(distance_bounderies == 0 && particles[i].interactions[l].direction < 0){
								//just bounce if they are attracting
								console.log("collision");
								elastic_bounce(particles[i], particles[j]);
							}
							else if( distance_center < particles[i].interactions[l].range )
							{
								//in range or interaction
								//based on newton's gravitation law
								var force = particles[i].interactions[l].direction * particles[i].interactions[l].force * particles[i].mass*particles[j].mass / Math.pow(distance_center, 2);
								//get the direction normalized
								var dir = [(particles[j].x - particles[i].x)/distance_center, (particles[j].y- particles[i].y)/distance_center];
								particles[j].vel[0]+=force * dir[0];
								particles[j].vel[1]+=force * dir[1];
							}
						}
						
					}
				}
			}
		}
	});
</script>
</body>
</html>